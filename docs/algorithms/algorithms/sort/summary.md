---
title: 小结
customTag: algorithms>算法>排序
date: 2024.05.22
editLink: true
---

# 总结

目前，我们已经把常用的排序方式进行了实现

具体如下

| 排序方式      | 描述                                                         | 时间复杂度（平均） | 时间复杂度（最坏） | 时间复杂度（最好） | 空间复杂度 |
|---------------|--------------------------------------------------------------|--------------------|--------------------|--------------------|------------|
| 冒泡排序      | 比较相邻元素，若顺序错误则交换，重复此过程直到无序元素为止 | O(n^2)             | O(n^2)             | O(n)               | O(1)       |
| 选择排序      | 从未排序部分选择最小（或最大）元素，与未排序部分的第一个元素交换 | O(n^2)             | O(n^2)             | O(n^2)             | O(1)       |
| 插入排序      | 将每个元素插入到已排序部分的适当位置                         | O(n^2)             | O(n^2)             | O(n)               | O(1)       |
| 归并排序      | 将数组分成两部分分别排序，然后合并已排序的部分               | O(n log n)         | O(n log n)         | O(n log n)         | O(n)       |
| 快速排序      | 选择基准元素，将小于基准的元素放在左边，大于基准的元素放在右边，递归排序 | O(n log n)         | O(n^2)             | O(n log n)         | O(log n)  |
| 堆排序        | 构建最大堆，将堆顶元素与末尾元素交换并调整堆，重复此过程    | O(n log n)         | O(n log n)         | O(n log n)         | O(1)       |
| 计数排序      | 统计每个元素出现的次数，然后按顺序输出                      | O(n + k)           | O(n + k)           | O(n + k)           | O(k)       |
| 桶排序        | 将元素分布到不同的桶中，每个桶内分别排序，再合并             | O(n + k)           | O(n^2)             | O(n)               | O(n + k)  |
| 基数排序      | 依次按位（从最低位到最高位或相反）进行排序                   | O(nk)              | O(nk)              | O(nk)              | O(n + k)  |

贴上一张 [hello 算法](https://www.hello-algo.com/chapter_sorting/summary/#1)的图

![alt text](https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png)