---
title: 选择排序
customTag: algorithms>算法>排序
date: 2024.04.01
editLink: true
---

# 选择排序

选择排序的思路：开启一个循环，每一个巡回选定一个未排序区间（i， n-1）, 每轮将最小的元素放在已经排序的末尾。

## **流程**

主要流程如下

1. 初始情况下，所有元素未排序，即未排序区间为\[0-n-1\]
2. 选取区间\[0, n-1\]最小元素，和索引 0 元素交互。这个时候，数组前一个元素已经排序。
3. 选取区间\[1, n-1\]最小元素，和索引 1 元素交互。这个时候，数组前一个元素已经排序。
4. 以此类推。经过  n−1  轮选择与交换后，数组前  n−1  个元素已排序。
5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。

## 代码

```ts
const selectionSort = (arr: number[]) => {
  let n = arr.length;

  for (let i = 0; i < n - 1; i++) {
    let k = i;
    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[k]) {
        k = j; // 记录最小元素的索引
      }
    }

    [arr[k], arr[i]] = [arr[i], arr[k]];
  }
};
```

## 特征

- **时间复杂度为 O(n^2)、非自适应排序**: 这里的非自适应排序指时间复杂度不随数据而进行变化。
- **空间复杂度为 O(1)、原地排序**：指针  i  和  j  使用常数大小的额外空间。
- - **非稳定排序**：如图 11-3 所示，元素  `nums[i]`  有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。

## 参考

- [选择排序](https://www.hello-algo.com/chapter_sorting/selection_sort/)
