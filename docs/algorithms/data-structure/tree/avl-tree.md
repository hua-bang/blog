---
title: AVL 树
customTag: algorithms>数据结构>树
editLink: true
---

计算机领域中，AVL 树是一种平衡的二叉搜索树。在 AVL 树中，同一节点的两个子节点树的高度不会相差大于 1。如果在任何时候它们相差不止一个，则进行重新平衡以恢复此属性。

## 概念

### 二叉搜索树

前文有提及，这里不做过多描述了哈。[二叉搜索树](/algorithms/data-structure/tree/binary-search-tree.html)

### 平衡

由于平衡在不同的场景，不同的数据结构中，可能定义略为不一样。我们这里主要探讨在平衡二叉树上下文的定义。

在平衡二叉树的上下文中，指的是一种特定的树结构属性，它旨在减小树的高度，以优化各种树操作（如查找、插入、删除等）的效率。

在 AVL 树（一种自平衡二叉搜索树）中，“平衡”被定义为树中任意节点的左右子树的高度差的绝对值不超过 1。用数学语言来描述就是，对于任何节点 N，设其左子树的高度为 H_L，右子树的高度为 H_R，则满足|H_L - H_R| ≤ 1。

这种平衡条件确保了树的形状尽可能接近完全二叉树，从而保持树的高度最小，进而使得查找、插入、删除等操作能在对数时间内完成。

### 平衡因子

平衡因子针对的对象是节点粒度。对于 AVL 树中的任何一个节点，其平衡因子被定义为该节点的左子树的高度减去其右子树的高度。用数学符号表示就是：`平衡因子=高度(左子树)− 高度(右子树)

![image.png](https://raw.githubusercontent.com/hua-bang/assert-store/master/20240322080622.png)

### 平衡情况

左左情况：指的是一种特定的不平衡状态，其中一个节点的左子树的左侧更重（即左子树的高度大于右子树的高度），并且这种不平衡状态发生在两级连续的左子节点上。这种情况需要通过右旋转操作来修正不平衡。
![image.png](https://raw.githubusercontent.com/hua-bang/assert-store/master/20240322082135.png)

## 性质

AVL 是一种平衡的二叉搜索树，我们抓住中间两个关键词，`平衡`, `二叉搜索树`。

那也就意味着有下方性质

- **高度平衡**：对于 AVL 树中的每一个节点，**其左子树和右子树的高度差（称为平衡因子）的绝对值不超过 1**。这意味着 AVL 树是高度平衡的，从而保证了树的深度大约是 logN（N 为树中节点数），确保了操作的高效性。

- **自平衡性**： 当通过插入或删除操作破坏了 AVL 树的高度平衡后，树会通过一系列的旋转操作自动恢复平衡。这些旋转操作包括单旋转（左旋和右旋）和双旋转（左-右旋和右-左旋）。

- **二叉搜索树的性质**： AVL 树是一种特殊的二叉搜索树，所以**它继承了二叉搜索树的所有性质**。例如，对于任意节点，其左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值。这一性质使得 AVL 树在执行查找、插入和删除操作时非常高效。

- **动态数据结构**： AVL 树是一个动态的数据结构，可以在**保持高度平衡的情况下动态地插入和删除节点。** 这使得 AVL 树非常适合于需要频繁更新的数据集合，如数据库索引和内存管理系统。

- **路径最优性**： 由于 AVL 树的高度平衡特性，**任意节点到根节点的最长可能路径不会超过 logN**，这保证了查找效率是对数级别的。因此，AVL 树在最坏情况下也能保证较好的查找性能。

- **旋转复杂性**： 尽管 AVL 树的旋转操作能够保证树的平衡，但这也意味着在每次插入或删除操作后可能需要进行多次旋转，这在某些情况下可能会导致操作成本较高。然而，通过智能地选择旋转类型和顺序，AVL 树能够最小化这种成本，以保证高效的操作性能。

AVL 树通过这些性质，为许多应用提供了一个既高效又可靠的数据结构方案，特别是在那些对查找、插入和删除操作的性能要求较高的场合。

## 旋转操作

从上文知道，AVL 主要是在插入/删除过程中进行不同的旋转，其中分为

- **右旋（Single Right Rotation）：** 当某个节点的左子树比右子树高，且左子树的左子树比左子树的右子树高时，对该节点进行右旋。
- **左旋（Single Left Rotation）：** 当某个节点的右子树比左子树高，且右子树的右子树比右子树的左子树高时，对该节点进行左旋。
- **左-右旋（Left-Right Rotation）：** 当某个节点的左子树比右子树高，且左子树的右子树比左子树的左子树高时，先对该节点的左子树进行左旋，然后对该节点进行右旋。
- **右-左旋（Right-Left Rotation）：** 当某个节点的右子树比左子树高，且右子树的左子树比右子树的右子树高时，先对该节点的右子树进行右旋，然后对该节点进行左旋。

### 右旋

右旋转是一种在 AVL 树或其他自平衡二叉搜索树中用来修正不平衡的操作。当一个节点的左子树的高度比右子树的高度大 2 时，即发生了左左不平衡（LL），这时可以通过右旋转来恢复平衡。

```
     A
    / \
   B   C
  /
 D
/
E
```

**右旋转步骤：**

1. **确定旋转的节点**：
   - 旋转发生在最小不平衡子树的根节点，在这个例子中是节点 A。
2. **旋转的操作**：
   - 将节点 B 提升为树的新根节点。
   - 将节点 A 降为节点 B 的右子节点。
   - 如果节点 B 有右子节点，这个右子节点将成为节点 A 的左子节点。
3. **更新引用**： - 原本 A 的左子节点是 B，现在 B 将变成新的根节点。 - 原本 B 的右子节点是 D，D 保持不变。 - 原本 A 的右子节点是 C，现在 A 降级后 C 保持为 A 的右子节点。
   **旋转后的树**

```
   B
  / \
 D   A
/     \
E      C
```

经过右旋转，平衡因子重新计算，树的平衡被恢复。这是一种简化版的解释，实际的 AVL 树还会在每一步操作后更新每个节点的高度信息。

代码实现

```ts
function getHeight(node: AVLNode | null): number {
  if (node === null) {
    return 0;
  }
  return node.height;
}

function rightRotate(y: AVLNode): AVLNode {
  const x = y.left!;
  const temp = x.right;

  y.left = temp;
  x.right = y;

  y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
  x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;

  return x;
}

// Usage
const root = new AVLNode(30);
root.left = new AVLNode(20);
root.right = new AVLNode(40);
root.left.left = new AVLNode(10);
root.left.left.left = new AVLNode(5);

// Assuming the tree needs a right rotation at the root
const newRoot = rightRotate(root);
```
