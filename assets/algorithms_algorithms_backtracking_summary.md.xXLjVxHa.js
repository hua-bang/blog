import{_ as a,c as t,o as r,a3 as e}from"./chunks/framework.ChvKBEtN.js";const u=JSON.parse('{"title":"总结","description":"","frontmatter":{"title":"总结","customTag":"algorithms>算法>回溯","date":"2024.05.29","editLink":true},"headers":[],"relativePath":"algorithms/algorithms/backtracking/summary.md","filePath":"algorithms/algorithms/backtracking/summary.md","lastUpdated":1717684515000}'),o={name:"algorithms/algorithms/backtracking/summary.md"},l=e('<h1 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h1><h2 id="要点总结" tabindex="-1">要点总结 <a class="header-anchor" href="#要点总结" aria-label="Permalink to &quot;要点总结&quot;">​</a></h2><ol><li>回溯算法的本质是<strong>暴力穷尽</strong>，一般使用深度优先搜索来寻找符合条件的解。搜索过成功中，遇到满足条件的则记录，直到遍历完所有情况，或者满足条件。</li><li>回溯算法分为<strong>尝试和回退</strong>。它通过深度优先搜索来尝试各种选择，当遇到不满足约束条件的情况时，则撤销上一步的选择，退回到之前的状态，并继续尝试其他选择。尝试与回退是两个方向相反的操作。</li><li><strong>回溯过程常常包含约束条件，可以用于进行剪枝</strong>。减少不必要的遍历情况。</li><li>回溯算法主要可用于解决搜索问题和约束满足问题。组合优化问题虽然可以用回溯算法解决，但往往存在效率更高或效果更好的解法。</li></ol><h2 id="q-a" tabindex="-1">Q &amp; A <a class="header-anchor" href="#q-a" aria-label="Permalink to &quot;Q &amp; A&quot;">​</a></h2><p>如何理解回溯和递归的关系。</p><p>总的来看，回溯是一种“算法策略”，而递归更像是一个“工具”。</p><p>回溯算法通常基于递归实现。然而，回溯是递归的应用场景之一，是递归在搜索问题中的应用。 递归的结构体现了“子问题分解”的解题范式，常用于解决分治、回溯、动态规划（记忆化递归）等问题。</p><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><ul><li><a href="https://www.hello-algo.com/chapter_backtracking/summary/#1" target="_blank" rel="noreferrer">hello 算法</a></li></ul>',9),i=[l];function s(n,c,h,m,d,_){return r(),t("div",null,i)}const g=a(o,[["render",s]]);export{u as __pageData,g as default};
