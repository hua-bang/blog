import{_ as a,c as t,o as l,l as e,a as i}from"./chunks/framework.BIfXPdSt.js";const g=JSON.parse('{"title":"总结","description":"","frontmatter":{"title":"总结","customTag":"algorithms>算法>分治","date":"2024.05.24","editLink":true},"headers":[],"relativePath":"algorithms/algorithms/divide_and_conquer/summary.md","filePath":"algorithms/algorithms/divide_and_conquer/summary.md","lastUpdated":1719018486000}'),r={name:"algorithms/algorithms/divide_and_conquer/summary.md"},s=e("h1",{id:"总结",tabindex:"-1"},[i("总结 "),e("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),n=e("ul",null,[e("li",null,"分治是一种常见的算法设计策略，包括分（划分）和治（合并）两个阶段，通常基于递归实现。"),e("li",null,"判断是否是分治算法问题的依据包括：问题能否分解、子问题是否独立、子问题能否合并。"),e("li",null,"归并排序是分治策略的典型应用，其递归地将数组划分为等长的两个子数组，直到只剩一个元素时开始逐层合并，从而完成排序。"),e("li",null,"引入分治策略往往可以提升算法效率。一方面，分治策略减少了操作数量；另一方面，分治后有利于系统的并行优化。"),e("li",null,"二分查找是分治策略的另一个典型应用，它不包含将子问题的解进行合并的步骤。我们可以通过递归分治实现二分查找。"),e("li",null,"在构建二叉树的问题中，构建树（原问题）可以划分为构建左子树和右子树（子问题），这可以通过划分前序遍历和中序遍历的索引区间来实现。"),e("li",null,"在汉诺塔问题中，一个规模为 n 的问题可以划分为两个规模为 n-1 的子问题和一个规模为 1 的子问题。按顺序解决这三个子问题后，原问题随之得到解决。")],-1),o=[s,n];function d(c,m,u,_,h,p){return l(),t("div",null,o)}const v=a(r,[["render",d]]);export{g as __pageData,v as default};
