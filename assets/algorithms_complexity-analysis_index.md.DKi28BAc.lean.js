import{_ as a,c as o,o as r,a1 as n}from"./chunks/framework.BUQJ8Vm8.js";const h=JSON.parse('{"title":"算法效率评估","description":"","frontmatter":{"title":"算法效率评估","customTag":"algorithms>复杂度分析","date":"2025.01.11","editLink":true},"headers":[],"relativePath":"algorithms/complexity-analysis/index.md","filePath":"algorithms/complexity-analysis/index.md","lastUpdated":1743380565000}'),s={name:"algorithms/complexity-analysis/index.md"};function e(l,t,i,p,g,d){return r(),o("div",null,t[0]||(t[0]=[n('<h1 id="算法效率评估" tabindex="-1">算法效率评估 <a class="header-anchor" href="#算法效率评估" aria-label="Permalink to &quot;算法效率评估&quot;">​</a></h1><p>算法层面，我们无非解决两个问题</p><ol><li><strong>找到问题的解法</strong>: 最重要的一点是，他首先能解答问题。</li><li><strong>寻求最优解法</strong>: 其次，他需要尽可能的优化，以达到最优的性能, 一般从时间和空间两个维度来评估， 但往往在实际中，我们需要做权衡。</li></ol><p>所以，在效率评估中，我们主要关注的是 <strong>时间维度</strong> 和 <strong>空间维度</strong>。</p><ul><li><strong>时间维度</strong>: 评估算法执行的效率，一般用时间复杂度来表示。</li><li><strong>空间维度</strong>: 评估算法执行时所占用的内存空间，一般用空间复杂度来表示。</li></ul><p>最终，我们需要在时间和空间维度上找到一个平衡点，以达到最优的性能。</p><p>效率评估的两种方式，一种是 <strong>事后统计法</strong>， 一种是 <strong>事前分析法</strong>。</p><h2 id="事后统计法" tabindex="-1">事后统计法 <a class="header-anchor" href="#事后统计法" aria-label="Permalink to &quot;事后统计法&quot;">​</a></h2><p>事后统计法，顾名思义，就是通过实际运行程序来统计执行时间，比较偏实际。</p><ul><li><strong>优点</strong>: 直观， 真实</li><li><strong>缺点</strong>: 需要实际运行， 受环境影响大， 结果不准确</li></ul><h2 id="事前分析法" tabindex="-1">事前分析法 <a class="header-anchor" href="#事前分析法" aria-label="Permalink to &quot;事前分析法&quot;">​</a></h2><p>事前分析法，顾名思义，就是通过分析代码来预估执行时间，比较偏理论。</p><ul><li><strong>优点</strong>: 不需要实际运行， 结果准确</li><li><strong>缺点</strong>: 需要分析代码， 结果不准确</li></ul><p>当我们一般的评估的话，实际上还是事前分析法， 具体而言的话 <strong>复杂度分析</strong>。</p><p>注意，这里并非分析出具体执行的时间，而是通过一种相对的复杂度来评估执行时间， 如 O(1), O(n), O(n^2) 等。</p><p>复杂度分析的好处在于“量执行某个算法所需的时间和空间资源，对比不同算法之间的效率”</p>',16)]))}const m=a(s,[["render",e]]);export{h as __pageData,m as default};
