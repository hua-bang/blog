import{_ as t,c as a,o as r,a3 as e}from"./chunks/framework.ChvKBEtN.js";const o="/blog/assets/image.DICIT_CK.png",i="/blog/assets/image-1.zRgG7xeg.png",s="/blog/assets/image-2.cVzc0K4x.png",l="/blog/assets/image-3.CfX7xiGI.png",f=JSON.parse('{"title":"回溯算法","description":"","frontmatter":{"title":"回溯算法","customTag":"algorithms>算法>回溯","date":"2024.05.29","editLink":true},"headers":[],"relativePath":"algorithms/algorithms/backtracking/overview.md","filePath":"algorithms/algorithms/backtracking/overview.md","lastUpdated":1718115474000}'),n={name:"algorithms/algorithms/backtracking/overview.md"},d=e('<h1 id="回溯算法" tabindex="-1">回溯算法 <a class="header-anchor" href="#回溯算法" aria-label="Permalink to &quot;回溯算法&quot;">​</a></h1><p>回溯算法是一种用于寻找所有（或部分）解的一种算法。它通过逐步构建解决方案，并在发现部分解决方案不能通向最终解时回退（即“回溯”），尝试其他可能的路径。</p><p>以下是回溯算法的基本思想和步骤：</p><h2 id="基本思想" tabindex="-1">基本思想 <a class="header-anchor" href="#基本思想" aria-label="Permalink to &quot;基本思想&quot;">​</a></h2><p>回溯算法通常采用深度优先搜索来遍历解决问题。在每一步选择中，尝试每一种可能的选择，当发现某个选择不能得到有效解时，回退到上一步，尝试其他选择。</p><h2 id="算法步骤" tabindex="-1">算法步骤 <a class="header-anchor" href="#算法步骤" aria-label="Permalink to &quot;算法步骤&quot;">​</a></h2><ol><li><strong>选择路径</strong>：在当前步骤选择一个可能的选择。</li><li><strong>剪枝判断</strong>：检查当前选择是否满足问题的约束条件。如果不满足，则放弃当前选择（即剪枝）。</li><li><strong>递归处理</strong>：若当前选择满足条件，则继续递归处理下一个步骤。</li><li><strong>回溯</strong>：若通过当前选择不能得到解，撤销选择并返回上一步，尝试其他选择。</li></ol><h2 id="常用术语" tabindex="-1">常用术语 <a class="header-anchor" href="#常用术语" aria-label="Permalink to &quot;常用术语&quot;">​</a></h2><table><thead><tr><th>名词</th><th>定义</th></tr></thead><tbody><tr><td>解（solution）</td><td>解是满足问题特定条件的答案，可能有一个或多个</td></tr><tr><td>约束条件（constraint）</td><td>约束条件是问题中限制解的可行性的条件，通常用于剪枝</td></tr><tr><td>状态（state）</td><td>状态表示问题在某一时刻的情况，包括已经做出的选择</td></tr><tr><td>尝试（attempt）</td><td>尝试是根据可用选择来探索解空间的过程，包括做出选择，更新状态，检查是否为解</td></tr><tr><td>回退（backtracking）</td><td>回退指遇到不满足约束条件的状态时，撤销前面做出的选择，回到上一个状态</td></tr><tr><td>剪枝（pruning）</td><td>剪枝是根据问题特性和约束条件避免无意义的搜索路径的方法，可提高搜索效率</td></tr></tbody></table><h2 id="举个例子-🌰" tabindex="-1">举个例子 🌰 <a class="header-anchor" href="#举个例子-🌰" aria-label="Permalink to &quot;举个例子 🌰&quot;">​</a></h2><p>下面用二叉搜索树来举个例子</p><p><img src="'+o+'" alt="alt text"></p><h3 id="回退" tabindex="-1">回退 <a class="header-anchor" href="#回退" aria-label="Permalink to &quot;回退&quot;">​</a></h3><p><strong>场景</strong>：需要记录树节点值为奇数的节点。</p><p>在这个过程中，很明显是需要对整个树遍历的，在这个过程中，就会涉及到回退。</p><p>比如，我们通过中序遍历已经遍历到 3 节点了</p><p><img src="'+i+'" alt="alt text"></p><p>这个时候，我们进行会退到 5 节点, 其实这里也算回溯。</p><p><img src="'+s+'" alt="alt text"></p><h3 id="剪枝" tabindex="-1">剪枝 <a class="header-anchor" href="#剪枝" aria-label="Permalink to &quot;剪枝&quot;">​</a></h3><p><strong>场景</strong>：需要记录树节点值为大于 5 的节点。</p><p>在这个过程中，我们使用前序遍历，同时，我们这里是一个二叉搜索树。 这里，遍历到 5 了之后，我们可以把 5 进行剪枝操作。</p><p><img src="'+l+'" alt="alt text"></p><h2 id="优点与局限性" tabindex="-1">优点与局限性 <a class="header-anchor" href="#优点与局限性" aria-label="Permalink to &quot;优点与局限性&quot;">​</a></h2><p>回溯算法本质上是一种<strong>深度优先搜索算法</strong>，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，而且<strong>在合理的剪枝操作下，具有很高的效率</strong>。</p><p>然而，<strong>在处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受</strong>。</p><ul><li><strong>时间</strong>：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶。</li><li><strong>空间</strong>：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大。</li></ul><p>即便如此，<strong>回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案</strong>。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，关键是如何优化效率，常见的效率优化方法有两种。</p><ul><li><strong>剪枝</strong>：避免搜索那些肯定不会产生解的路径，从而节省时间和空间。</li><li><strong>启发式搜索</strong>：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径。</li></ul><h2 id="回溯算法应用" tabindex="-1">回溯算法应用 <a class="header-anchor" href="#回溯算法应用" aria-label="Permalink to &quot;回溯算法应用&quot;">​</a></h2><p>回溯算法可用于解决许多搜索问题、约束满足问题和组合优化问题。如<strong>搜索问题、约束满足问题、组合优化问题</strong>。</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://www.hello-algo.com/chapter_backtracking/backtracking_algorithm/#1315" target="_blank" rel="noreferrer">回溯算法</a></li></ul>',33),h=[d];function g(c,p,m,_,b,u){return r(),a("div",null,h)}const q=t(n,[["render",g]]);export{f as __pageData,q as default};
