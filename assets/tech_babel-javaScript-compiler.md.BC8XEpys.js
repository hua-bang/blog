import{_ as a,c as s,o as t,a1 as i}from"./chunks/framework.BUQJ8Vm8.js";const b=JSON.parse('{"title":"Babel: A JavaScript Compiler","description":"","frontmatter":{"title":"Babel: A JavaScript Compiler","customTag":"tech>编译","editLink":true,"date":"2023.11.02"},"headers":[],"relativePath":"tech/babel-javaScript-compiler.md","filePath":"tech/babel-javaScript-compiler.md","lastUpdated":1739091515000}'),n={name:"tech/babel-javaScript-compiler.md"};function l(r,e,o,p,c,d){return t(),s("div",null,e[0]||(e[0]=[i(`<h1 id="babel-a-javascript-compiler" tabindex="-1">Babel: A JavaScript Compiler <a class="header-anchor" href="#babel-a-javascript-compiler" aria-label="Permalink to &quot;Babel: A JavaScript Compiler&quot;">​</a></h1><h2 id="what" tabindex="-1">What <a class="header-anchor" href="#what" aria-label="Permalink to &quot;What&quot;">​</a></h2><p><code>Babel</code> 实质上是一个 <code>JavaScript</code> 的编译器（转译器），用于将 <code>es next</code>, <code>typescript</code> 等代码做相关的转换，同时暴露了相关的 <code>api</code> 给开发者做特定用途的转换。</p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/44b75b7bb9324f13800fbb80df031628%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/46d50c1c987342958a11ca131b788117%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="why" tabindex="-1">Why <a class="header-anchor" href="#why" aria-label="Permalink to &quot;Why&quot;">​</a></h2><p>我们为什么要使用 <code>Babel</code></p><ul><li>转译 <code>esnext</code>, <code>typescript</code>, <code>flow</code> 等到目标环境支持的 <code>javaScript</code>。</li></ul><ul><li>一些特定代码的转换。</li></ul><ul><li>代码的静态分析。</li></ul><h2 id="process" tabindex="-1">Process <a class="header-anchor" href="#process" aria-label="Permalink to &quot;Process&quot;">​</a></h2><p><strong>总结流程：</strong> 首先需要把源码字符串进行 <strong>parse,</strong> 生成 AST，对这个 AST 进行增删改的操作 <strong>，</strong> 再根据转换后的 AST 生成新的代码。</p><p>一般的<strong>编译流程</strong>分为三步：</p><ul><li><strong>Parse:</strong> 通过 <code>parser</code> 将源代码转换成<strong>抽象语法树(AST),</strong> 其中会涉及到 词法解析，语法解析等操作。</li></ul><ul><li><strong>Transform：</strong> 拿到了源码上对应的 <code>AST</code>, 我们可以去对这个<code>AST</code>, 进行增删改查的操作。其中会涉及到访问者模式的知识。</li></ul><ul><li><strong>Generate：</strong> 转换后的 <code>AST</code>，我们可以转换生成目标代码。</li></ul><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/94e9157c68ec409ea2001b27bc9b0ca0%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="process-detail" tabindex="-1">Process Detail <a class="header-anchor" href="#process-detail" aria-label="Permalink to &quot;Process Detail&quot;">​</a></h2><h3 id="parse" tabindex="-1">Parse <a class="header-anchor" href="#parse" aria-label="Permalink to &quot;Parse&quot;">​</a></h3><blockquote><p>Parse 阶段是将源码字符串转换成机器能够理解的 AST，这个过程分成此<strong>词法分析</strong>，<strong>语法分析</strong>。</p></blockquote><p><strong>词法分析</strong>：将字符串分成一个个规定好的 <code>token</code>。</p><p><strong>语法分析：</strong> 将一个个 <code>token</code> 进行拼接组装，按照不同的语法结构，来把一堆堆 <code>token</code> 进行组合拼接，生成 <code>AST</code> ，声明语句，赋值表达式都有对应的 <code>AST</code> 节点。</p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/8813ad14658b46da92612fad423c4fe9%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="transform" tabindex="-1">Transform <a class="header-anchor" href="#transform" aria-label="Permalink to &quot;Transform&quot;">​</a></h3><blockquote><p>Transform 主要是对生成的 AST 进行处理，会进行 AST 的遍历，可以对对应的 AST 节点进行处理。</p></blockquote><p>下方是一个在 log 函数添加新的参数节点的示意图，注意，这里只是表达添加参数节点，并不代表实际节点这么使用。</p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/d8091caecb4145f9bc1fe972ae0f3496%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="generate" tabindex="-1">Generate <a class="header-anchor" href="#generate" aria-label="Permalink to &quot;Generate&quot;">​</a></h3><blockquote><p>Generate 阶段会根据 AST 生成新的字符串，并生成对应的 SouceMap。</p></blockquote><p>不同的 AST 对应的不同结构的字符串。比如 <code>VariableDeclaration</code> 就可以打印成 <code>const</code> 格式的代码。</p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/df5e1a0fd0274580aefe2d1ac5990774%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="basic" tabindex="-1">Basic <a class="header-anchor" href="#basic" aria-label="Permalink to &quot;Basic&quot;">​</a></h2><h3 id="ast" tabindex="-1">AST <a class="header-anchor" href="#ast" aria-label="Permalink to &quot;AST&quot;">​</a></h3><blockquote><p><strong>Babel 的 AST</strong>：<a href="https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md" target="_blank" rel="noreferrer">github.com</a></p><p><strong>AST 可视化工具</strong>：<a href="https://astexplorer.net/" target="_blank" rel="noreferrer">AST explorer</a></p></blockquote><table><thead><tr><th><strong>类型</strong></th><th><strong>含义</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>Literal</strong></td><td>字面量，数字字面量 NumericLiteral，布尔字面量 BooleanLiteral，字符串字面量 StringLiteral，正则表达式字面量 RegExpLiteral</td><td></td></tr><tr><td><strong>Identifier</strong></td><td>Identifer 是标识符的意思，变量名、属性名、参数名等各种声明和引用的名字，都是 Identifer。</td><td></td></tr><tr><td><strong>Statement</strong></td><td>statement 是语句，它是可以独立执行的单位，比如 break、continue、debugger、return 或者 if 语句、while 语句、for 语句，还有声明语句，表达式语句等。</td><td></td></tr><tr><td><strong>Declaration</strong></td><td>声明语句是一种特殊的语句，它执行的逻辑是在作用域内声明一个变量、函数、class、import、export 等。</td><td></td></tr><tr><td><strong>Expression</strong></td><td>expression 是表达式，特点是执行完以后有返回值，这是和语句 (statement) 的区别。</td><td></td></tr><tr><td><strong>Class</strong></td><td>class 的语法也有专门的 AST 节点来表示。</td><td></td></tr><tr><td><strong>Modules</strong></td><td>es module 是语法级别的模块规范，所以也有专门的 AST 节点。</td><td></td></tr><tr><td><strong>Program &amp; Directive</strong></td><td>program 是代表整个程序的节点，它有 body 属性代表程序体，存放 statement 数组，就是具体执行的语句的集合。还有 directives 属性，存放 Directive 节点，比如<code>&quot;use strict&quot;</code> 这种指令会使用 Directive 节点表示。</td><td></td></tr><tr><td><strong>File</strong></td><td>babel 的 AST 最外层节点是 File，它有 program、comments、tokens 等属性，分别存放 Program 程序体、注释、token 等，是最外层节点。</td><td></td></tr><tr><td><strong>Comment</strong></td><td>注释分为块注释和行内注释，对应 CommentBlock 和 CommentLine 节点。</td><td></td></tr></tbody></table><p><strong>AST 公共属性</strong></p><p>每种 AST 都有自己的属性，但是它们也有一些公共的属性：</p><ul><li><code>type</code>： AST 节点的类型</li></ul><ul><li><code>start、end、loc</code>：start 和 end 代表该节点在源码中的开始和结束下标。而 loc 属性是一个对象，有 line 和 column 属性分别记录开始和结束的行列号。</li></ul><ul><li><code>leadingComments、innerComments、trailingComments</code>： 表示开始的注释、中间的注释、结尾的注释，每个 AST 节点中都可能存在注释，而且可能在开始、中间、结束这三种位置，想拿到某个 AST 的注释就通过这三个属性。</li></ul><ul><li><code>extra</code>：记录一些额外的信息，用于处理一些特殊情况。比如 StringLiteral 的 value 只是值的修改，而修改 extra.raw 则可以连同单双引号一起修改。</li></ul><h3 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API&quot;">​</a></h3><blockquote><p><a href="https://babeljs.io/docs/en/babel-parser" target="_blank" rel="noreferrer">babeljs.io</a></p></blockquote><p>上方介绍了 <code>babel</code> 的编译流程：<code>parse</code>, <code>transform</code>, <code>generate</code> 三个步骤，对于这三个步骤，<code>babel</code> 都有暴露对应的 <code>api</code>。</p><ul><li><strong>parse:</strong> 提供 <code>@babel/parser</code>, 将源码转成 <strong>AST。</strong></li></ul><ul><li><strong>transform:</strong> 提供 <code>@babel/traverse</code>, 可以遍历 <strong>AST,</strong> 用 <code>visitor</code> 函数修改 <code>AST</code>, 修改<code>AST</code>会涉及 <code>AST</code> 的判断，创建，修改，这个时候需要 <code>@babel/type</code>, 如果需要批量操作的话，可以使用 <code>@babel/template</code> 来简化 <strong>AST</strong> 的创建逻辑。</li></ul><ul><li><strong>generate:</strong> 将 <strong>AST</strong> 打印成目标代码字符串，同时生成 <code>sourcemap</code>, 需要 <code>@babel/generator</code>。</li></ul><ul><li>中途遇到错误想打印代码位置的时候，使用 <code>@babel/code-frame</code> 包</li></ul><ul><li>babel 的整体功能通过 <code>@babel/core</code> 提供，基于上面的包完成 babel 整体的编译流程，并应用 plugin 和 preset。</li></ul><h4 id="babel-parser" tabindex="-1">@babel/parser <a class="header-anchor" href="#babel-parser" aria-label="Permalink to &quot;@babel/parser&quot;">​</a></h4><blockquote><p>The Babel parser is a JavaScript parser used in Babel. Based on acorn.</p></blockquote><p>babel parser 默认只能 parse js 代码，jsx、flow、typescript 这些非标准的语法的解析需要指定语法插件。</p><p><strong>API</strong></p><ul><li><code>babelParser.parse(code, [options])</code></li></ul><ul><li><code>babelParser.parseExpression(code, [options])</code></li></ul><p><code>parse()</code> parses the provided <code>code</code> as an entire ECMAScript program, while <code>parseExpression()</code> tries to parse a single Expression with performance in mind. When in doubt, use <code>.parse()</code>.</p><p><strong>Options</strong></p><ul><li><code>plugins</code>： 指定 jsx、typescript、flow 等插件来解析对应的语法</li></ul><ul><li><code>allowXxx</code>： 指定一些语法是否允许，比如函数外的 await、没声明的 export 等</li></ul><ul><li><code>sourceType</code>： 指定是否支持解析模块语法，有 module、script、unambiguous 3 个取值：</li></ul><ul><li><code>strictMode</code>：是否是严格模式</li></ul><ul><li><code>startLine</code>：从源码哪一行开始 parse</li></ul><ul><li><code>errorRecovery</code>：出错时是否记录错误并继续往下 parse</li></ul><ul><li><code>tokens</code>：parse 的时候是否保留 token 信息</li></ul><ul><li><code>ranges</code>：是否在 ast 节点中添加 ranges 属性</li></ul><p><strong>Output</strong></p><p>The Babel parser generates AST according <a href="https://github.com/babel/babel/blob/main/packages/babel-parser/ast/spec.md" target="_blank" rel="noreferrer">Babel AST Format</a>. It is based on <a href="https://github.com/estree/estree" target="_blank" rel="noreferrer">ESTree spec</a> with the following deviations.</p><h4 id="babel-traverse" tabindex="-1">@babel/traverse <a class="header-anchor" href="#babel-traverse" aria-label="Permalink to &quot;@babel/traverse&quot;">​</a></h4><blockquote><p><a href="https://babeljs.io/docs/en/babel-traverse" target="_blank" rel="noreferrer">@babel/traverse · Babel</a></p></blockquote><p>经过 <code>parse</code> 阶段，我们能拿到对应的 <code>AST</code>, 我们可以通过 <code>@babel/traverse</code> 来进行遍历或修改， <code>babel traverse</code> 包提供了 <code>traverse</code> 方法。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function traverse(ast, options);</span></span></code></pre></div><p><strong>Params</strong></p><ul><li><strong>ast</strong>: 需要遍历的 <strong><code>AST</code></strong> 节点。</li></ul><ul><li><strong>opts：</strong> 指定 <strong><code>visitor</code></strong> 函数 <strong>。</strong></li></ul><p>babel 会在遍历 parent 对应的 AST 时调用相应的 visitor 函数。</p><p><strong>Example</strong></p><p><code>enter</code> 及 <code>exit</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>traverse(ast, {</span></span>
<span class="line"><span>  FunctionDeclaration: {</span></span>
<span class="line"><span>    enter(path, state) {},</span></span>
<span class="line"><span>    exit(path, state) {}</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>});</span></span></code></pre></div><p><code>only enter</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>traverse(ast, {</span></span>
<span class="line"><span>  FunctionDeclaration(path, state) {} // 进入节点时调用</span></span>
<span class="line"><span>})</span></span></code></pre></div><p><code>enter</code> 时调用是在遍历当前节点的子节点前调用，<code>exit</code> 时调用是遍历完当前节点的子节点后调用。</p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/0d485a56c4e4414dab34f3e3987eeb15%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>Path</strong></p><blockquote><p>AST 是棵树,遍历过程中肯定是有个路径的，path 记录了这个路径。（具体来说 Path 是表示两个节点之间连接的对象）</p></blockquote><p>path 中提供的内容：</p><ul><li><p>获取节点信息</p><ul><li>path.node 指向当前的 AST 节点</li><li>path.parent 指向父级 AST 节点</li><li>path.getSibling、path.getNextSibling、path.getPrevSibling 获取兄弟节点</li><li>path.find 从当前节点向上查找节点</li><li>path.get、path.set 获取 / 设置属性的 path</li></ul></li></ul><ul><li><p>获取作用域</p><ul><li>path.scope 获取当前节点的作用域信息</li></ul></li></ul><ul><li><p>判断 AST 类型</p><ul><li>path.isXxx 判断当前节点是不是 xx 类型</li><li>path.assertXxx 判断当前节点是不是 xx 类型，不是则抛出异常</li></ul></li></ul><ul><li><p>AST 进行增删改</p><ul><li>path.insertBefore、path.insertAfter 插入节点</li><li>path.replaceWith、path.replaceWithMultiple、replaceWithSourceString 替换节点</li><li>path.remove 删除节点</li></ul></li></ul><p>跳过遍历的：</p><ul><li>path.skip 跳过当前节点的子节点的遍历</li></ul><ul><li>path.stop 结束后续遍历</li></ul><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/a8524eeceb424d37a28b239d7a49117c%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>State</strong></p><blockquote><p>State 主要是在遍历过程做相关的数据传输工作。插件会通过 state 传递 options 和 file 信息，我们也可以通过 state 存储一些遍历过程中的共享数据</p></blockquote><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/a66b1b4262ea413fabd00ff8f127625c%7Etplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h4 id="babel-types" tabindex="-1">@babel/types <a class="header-anchor" href="#babel-types" aria-label="Permalink to &quot;@babel/types&quot;">​</a></h4><blockquote><p>This module contains methods for building ASTs manually and for checking the types of AST nodes.</p><p><a href="https://babeljs.io/docs/en/babel-types" target="_blank" rel="noreferrer">babeljs.io</a></p></blockquote><p>Types 提供了<strong>节点生成</strong>以及<strong>检测节点类型</strong>的能力。</p><p><strong>Node Builders:</strong> 节点生成</p><p>举例来说，如果要创建 IfStatement 就可以调用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>t.ifStatement(test, consequent, alternate);</span></span></code></pre></div><p><strong>Aliases:</strong> 节点类型检测</p><p>而判断节点是否是 IfStatement 就可以调用 isIfStatement 或者 assertIfStatement</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>t.isIfStatement(node, opts);</span></span>
<span class="line"><span>t.assertIfStatement(node, opts);</span></span></code></pre></div><h4 id="babel-template" tabindex="-1">@babel/template <a class="header-anchor" href="#babel-template" aria-label="Permalink to &quot;@babel/template&quot;">​</a></h4><blockquote><p><a href="https://babeljs.io/docs/en/babel-template" target="_blank" rel="noreferrer">@babel/template · Babel</a></p></blockquote><p>通过 @babel/types 创建 AST 还是比较麻烦的，要一个个的创建然后组装，如果 AST 节点比较多的话需要写很多代码，这时候就可以使用 <code>@babel/template</code> 包来批量创建。</p><p>这个包有这些 api：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>const ast = template(code, [opts])(args);</span></span>
<span class="line"><span>const ast = template.ast(code, [opts]);</span></span>
<span class="line"><span>const ast = template.program(code, [opts]);</span></span></code></pre></div><p>这些都是传入一段字符串，返回创建好的 AST，区别只是返回的 AST 粒度不大一样。</p><h4 id="babel-generator" tabindex="-1">@babel/generator <a class="header-anchor" href="#babel-generator" aria-label="Permalink to &quot;@babel/generator&quot;">​</a></h4><blockquote><p>Turns AST into code.</p></blockquote><p>AST 转换完之后就要打印成目标代码字符串，通过 <code>@babel/generator</code> 包的 generate api</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>function (ast: Object, opts: Object, code: string): {code, map}</span></span></code></pre></div><p>第一个参数是要打印的 AST。</p><p>第二个参数是 options，指定打印的一些细节，比如通过 comments 指定是否包含注释，通过 minified 指定是否包含空白字符。</p><p>第三个参数当多个文件合并打印的时候需要用到，这部分直接看<a href="https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-generator" target="_blank" rel="noreferrer">文档</a>即可，基本用不到。</p><p>options 中常用的是 sourceMaps，开启了这个选项才会生成 sourcemap。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>import generate from &quot;@babel/generator&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const { code, map } = generate(ast, { sourceMaps: true })</span></span></code></pre></div><h4 id="babel-core" tabindex="-1">@babel/core <a class="header-anchor" href="#babel-core" aria-label="Permalink to &quot;@babel/core&quot;">​</a></h4><blockquote><p><a href="https://babeljs.io/docs/en/babel-core" target="_blank" rel="noreferrer">https://babeljs.io/docs/en/babel-core</a></p></blockquote><p>前面讲了 @babel/parser、@babel/traverse、@babel/generaotr、@babel/types、@babel/template 等包，babel 的功能就是通过这些包来实现的。</p><p>babel 基于这些包来实现编译、插件、预设等功能的包就是 @babel/core。</p><p>这个包的功能就是完成整个编译流程，从源码到目标代码，生成 sourcemap。实现 plugin 和 preset 的调用。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>transformSync(code, options); // =&gt; { code, map, ast }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>transformFileSync(filename, options); // =&gt; { code, map, ast }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>transformFromAstSync(</span></span>
<span class="line"><span>  parsedAst,</span></span>
<span class="line"><span>  sourceCode,</span></span>
<span class="line"><span>  options</span></span>
<span class="line"><span>); // =&gt; { code, map, ast }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>transformAsync(&quot;code();&quot;, options).then(result =&gt; {})</span></span>
<span class="line"><span>transformFileAsync(&quot;filename.js&quot;, options).then(result =&gt; {})</span></span>
<span class="line"><span>transformFromAstAsync(parsedAst, sourceCode, options).then(result =&gt; {})</span></span></code></pre></div><ul><li><code>@babel/parser</code> 对源码进行 parse，可以通过 plugins、sourceType 等来指定 parse 语法</li></ul><ul><li><code>@babel/traverse</code> 通过 visitor 函数对遍历到的 ast 进行处理，分为 enter 和 exit 两个阶段，具体操作 AST 使用 path 的 api，还可以通过 state 来在遍历过程中传递一些数据</li></ul><ul><li><code>@babel/types</code> 用于创建、判断 AST 节点，提供了 xxx、isXxx、assertXxx 的 api</li></ul><ul><li><code>@babel/template</code> 用于批量创建节点</li></ul><ul><li><code>@babel/code-frame</code> 可以创建友好的报错信息</li></ul><ul><li><code>@babel/generator</code> 打印 AST 成目标代码字符串，支持 comments、minified、sourceMaps 等选项。</li></ul><ul><li><code>@babel/core</code> 基于上面的包来完成 babel 的编译流程，可以从源码字符串、源码文件、AST 开始。</li></ul><h2 id="demo" tabindex="-1">Demo <a class="header-anchor" href="#demo" aria-label="Permalink to &quot;Demo&quot;">​</a></h2><p>我们可以实现一个小功能，在所有的标签元素绑定上 <code>data-id</code> 属性，用 babel 插件就可以简单实现。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">babel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">types</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> babel;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;autoTrackerPlugin&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    visitor: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      JSXOpeningElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">state</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pushContainer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &quot;attributes&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jsxAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">jsxIdentifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data-id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            t.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">stringLiteral</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`loggerId-\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>DEMO</strong> 效果请看：<a href="https://astexplorer.net/#/gist/ac67eabb79019755143dfd0758e4102c/90b8b1e059e7a2467f221c4a057fd1b763911101" target="_blank" rel="noreferrer">https://astexplorer.net/#/gist/ac67eabb79019755143dfd0758e4102c/90b8b1e059e7a2467f221c4a057fd1b763911101</a></p><h1 id="参考资料" tabindex="-1">参考资料 <a class="header-anchor" href="#参考资料" aria-label="Permalink to &quot;参考资料&quot;">​</a></h1><ul><li><a href="https://nodepie.com/2021/04/06/AST/" target="_blank" rel="noreferrer">AST - nodepie</a></li><li><a href="https://astexplorer.net/" target="_blank" rel="noreferrer">astexplorer</a></li></ul>`,139)]))}const g=a(n,[["render",l]]);export{b as __pageData,g as default};
