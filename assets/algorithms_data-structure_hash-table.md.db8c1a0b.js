import{_ as e,o as a,c as o,Q as t}from"./chunks/framework.71c8f1eb.js";const k=JSON.parse('{"title":"哈希表","description":"","frontmatter":{"title":"哈希表","customTag":"algorithms>数据结构","editLink":true},"headers":[],"relativePath":"algorithms/data-structure/hash-table.md","filePath":"algorithms/data-structure/hash-table.md","lastUpdated":1710254097000}'),s={name:"algorithms/data-structure/hash-table.md"},l=t('<h1 id="哈希表" tabindex="-1">哈希表 <a class="header-anchor" href="#哈希表" aria-label="Permalink to &quot;哈希表&quot;">​</a></h1><p>在计算机领域的定义中，哈希表（hash map or hash table）是一种实现关联数组(associative array)的抽象数据类型，该结构可以将键(key)映射成值(value)。</p><blockquote><p>关联数组，也被称为映射（Map）或字典（Dictionary），是一种允许我们使用键（Key）而不是数字索引来存储和访问数据的数据结构。</p><ul><li>关联：根据 key 能关联（映射）value。</li><li>数组：底层还是基于数组做数据存储，但可以通过一些规则（如哈希表通过哈希函数）将 key -&gt; 索引，从而根据索引去找数组中具体的值。</li></ul></blockquote><p>哈希表使用 哈希函数/散列函数 来计算一个值在数组或桶(buckets)中或槽(slots)中对应的索引,可使用该索引找到所需的值。</p><p>理想情况下，哈希函数会给每一个键有唯一的桶，但是大多数的哈希表设计采用不完美的散列函数，可能会导致“哈希冲突”，也就是散列函数为多个键(key)生成了相同的索引,这种碰撞必须以某种方式进行处理。</p><p><img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/20240312221712.png" alt="image.png"></p><h2 id="哈希函数" tabindex="-1">哈希函数 <a class="header-anchor" href="#哈希函数" aria-label="Permalink to &quot;哈希函数&quot;">​</a></h2><p>哈希函数，又称散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。</p><h3 id="主要特性" tabindex="-1">主要特性 <a class="header-anchor" href="#主要特性" aria-label="Permalink to &quot;主要特性&quot;">​</a></h3><ol><li><strong>确定性</strong>：同一个输入数据每次通过哈希函数得到的哈希值都是相同的。</li><li><strong>高效性</strong>：哈希函数对数据的处理速度应当快速，能够迅速返回哈希值。</li><li><strong>随机分布性</strong>：对于输入数据的微小改动，产生的哈希值应该有很大的不同，这被称为雪崩效应。</li><li><strong>不可逆性</strong>：从哈希值不应能够直接反推出原始数据（单向性）。</li></ol><h3 id="常见的哈希函数" tabindex="-1">常见的哈希函数 <a class="header-anchor" href="#常见的哈希函数" aria-label="Permalink to &quot;常见的哈希函数&quot;">​</a></h3><p>哈希函数的种类很多，有哈希函数有很多种，它们各自适用于不同的应用场景。以下是一些常见的哈希函数：</p><ol><li><p><strong>除法哈希（Division Hashing）</strong>: 这种函数通过取关键字与哈希表大小的模（余数）来分配索引，即 <code>h(k) = k mod m</code>，其中 <code>k</code> 是关键字，<code>m</code> 是表大小。</p></li><li><p><strong>乘法哈希（Multiplication Hashing）</strong>: 这里，关键字乘以一个常数，取结果的分数部分，并乘以表的大小，最后取整。公式如 <code>h(k) = floor(m * (k * A mod 1))</code>，<code>A</code> 是 0 和 1 之间的常数。</p></li><li><p><strong>通用哈希（Universal Hashing）</strong>: 随机选取哈希函数的系列，以此来减少哈希碰撞的几率。</p></li><li><p><strong>平方取中哈希</strong>: 关键字平方后取中间几位作为哈希值，以尽量避免碰撞。</p></li></ol><p>具体的哈希函数设计，取决于你的具体场景。</p><h2 id="哈希冲突" tabindex="-1">哈希冲突 <a class="header-anchor" href="#哈希冲突" aria-label="Permalink to &quot;哈希冲突&quot;">​</a></h2><p>哈希冲突（Hash Collision）是指两个不同的输入数据（或称为键）在使用同一个哈希函数处理后得到相同的哈希值的情况。由于哈希函数是将一个较大（通常是无限的）输入域映射到一个较小（通常是有限的）输出域，因此根据鸽巢原理，在足够多的输入或特定的条件下，必然会出现至少两个不同的输入得到相同输出的情况。</p><h3 id="具体例子" tabindex="-1">具体例子 <a class="header-anchor" href="#具体例子" aria-label="Permalink to &quot;具体例子&quot;">​</a></h3><p>具体来说，考虑一个哈希函数 <code>h</code>，它将输入空间 <code>I</code> 映射到输出空间 <code>O</code>。如果存在两个不同的输入 <code>x</code> 和 <code>y</code>（x ≠ y），使得 <code>h(x) = h(y)</code>，那么我们就说发生了一个哈希冲突。</p><p>哈希冲突的示例：考虑一个简单的哈希函数 <code>h(k) = k mod 10</code>，并且有两个不同的键 <code>k1 = 12</code> 和 <code>k2 = 22</code>。当应用哈希函数 <code>h</code> 到 <code>k1</code> 和 <code>k2</code> 上时，得到：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">h(12) = 12 mod 10 = 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">h(12) = 12 mod 10 = 2</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">h(22) = 22 mod 10 = 2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">h(22) = 22 mod 10 = 2</span></span></code></pre></div><p>在这个例子中，<code>k1</code> 和 <code>k2</code> 发生了哈希冲突，因为它们具有相同的哈希值 2。</p><h3 id="解决策略" tabindex="-1">解决策略 <a class="header-anchor" href="#解决策略" aria-label="Permalink to &quot;解决策略&quot;">​</a></h3><p>在哈希表的实现中，冲突解决策略是必须的，以确保每个输入值都能够被正确处理。以下是一些常见的冲突解决方法：</p><ol><li><p><strong>开放寻址（Open Addressing）</strong>：如果产生了冲突，就按某种系统的方式探查哈希表的其他位置来找到空位。</p></li><li><p><strong>链表法（Chaining）</strong>：在哈希表的每个槽位上维护一个链表，所有具有相同哈希值的输入项都存储在相同槽位的链表中。</p></li><li><p><strong>双重散列（Double Hashing）</strong>：使用一组哈希函数而不是单一哈希函数，在发生冲突时使用另一个哈希函数来确定探查序列。</p></li><li><p><strong>再哈希（Rehashing）</strong>：当哈希表变得过于拥挤时（即装填因子变大），使用一个新的哈希函数和更大的哈希表大小进行再哈希，以减少冲突并重新分配已有的项。</p></li></ol>',25),i=[l];function r(c,n,d,p,h,g){return a(),o("div",null,i)}const m=e(s,[["render",r]]);export{k as __pageData,m as default};
