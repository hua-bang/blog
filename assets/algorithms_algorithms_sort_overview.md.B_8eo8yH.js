import{_ as a,c as r,o as e,a1 as o}from"./chunks/framework.BUQJ8Vm8.js";const d=JSON.parse('{"title":"排序算法","description":"","frontmatter":{"title":"排序算法","customTag":"algorithms>算法>排序","date":"2024.04.01","editLink":true},"headers":[],"relativePath":"algorithms/algorithms/sort/overview.md","filePath":"algorithms/algorithms/sort/overview.md","lastUpdated":1742008489000}'),s={name:"algorithms/algorithms/sort/overview.md"};function n(i,t,l,g,h,m){return e(),r("div",null,t[0]||(t[0]=[o('<h1 id="排序算法" tabindex="-1">排序算法 <a class="header-anchor" href="#排序算法" aria-label="Permalink to &quot;排序算法&quot;">​</a></h1><p><strong>排序算法是一类算法，其核心目的是将一组数据按照特定顺序重新排列。</strong> 通常，这个顺序是按照数字的大小或字母的顺序进行的。</p><ul><li>数值排序 <img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/20240418081844.png" alt="image.png"></li><li>自定义规则排序 <img src="https://raw.githubusercontent.com/hua-bang/assert-store/master/20240418081925.png" alt=""></li></ul><h2 id="评价维度" tabindex="-1">评价维度 <a class="header-anchor" href="#评价维度" aria-label="Permalink to &quot;评价维度&quot;">​</a></h2><p><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。 <strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。 <strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。 <strong>自适应性</strong>：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。 <strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为  O(nlog⁡n) 。而非比较排序不使用比较运算符，时间复杂度可达  O(n) ，但其通用性相对较差。</p><h2 id="理想排序算法" tabindex="-1">理想排序算法 <a class="header-anchor" href="#理想排序算法" aria-label="Permalink to &quot;理想排序算法&quot;">​</a></h2><p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。</p>',7)]))}const p=a(s,[["render",n]]);export{d as __pageData,p as default};
